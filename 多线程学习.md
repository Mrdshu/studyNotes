# Java多线程学习

# 基础概念

### 1. 串行、并发、并行
- 串行：按照顺序依次执行任务
- 并发：交替执行任务
- 并行：以齐头并进的形式执行任务

并行可看作并发的一种特例。并发往往带有部分串行的并发，而并发的极致是并行

### 2. 竞态
多线程在没有任何控制措施的情况下，并发的更新、读取同一共享变量导致运算结果最终错误。例如多线程执行`i++`这一操作就会产生竞态。

竟态有两种模式：读改写模式、检查后行动模式
#### 2.1. read-modify-write模式
读写改模式，例如`i++`可以分解为以下三步:
```
1. 从内存中读取i值到寄存器（读）
2. i = i + 1（改）
3. 将更新后的i值写入内存(写)
```
#### 2.2. check-then-act模式
检查后行动模式，多线程执行下段代码时，会导致seq进入act时，值可能已经不是0：
```
if(seq = 0){ //检查seq值
  seq ++;  //行动
}
```

### 3. 线程安全
线程安全可总结为三个特性：原子性、可见性、有序性
满足这三个特性的操作才是线程安全的

#### 3.1. 原子性
**一个操作或多个操作，在其执行线程以外的线程看来，要么全部执行完成，要么就不执行，这就是原子性**。也可以理解为原子性操作就是不被线程调度器中断的操作。

Java中有两种方式保证原子性：锁（`Lock`或者`synchronized`）、硬件锁（CAS）

Java中除`long`和`double`外任何类型的变量的写操作都是原子操作，对任何类型变量的读操作都是原子操作。`long`和`double`可用`volatile`来修饰保证写操作的原子性

竟态的两种模式可以通过保证原子性来消除。（实际上由于两种模式最后都将变量写入了内存，所以也是可见性的。）

#### 3.2. 可见性
**当多个线程同时访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值** 。

可见性的问题可能由两种情况造成：

**1. JIT编译器对代码进行优化，导致其他线程更改变量后，本线程变量没有更新。**
例如：
```
while (!toCancel) {
      if (doExecute()) {
        break;
      }
    }
```
优化后代码为
```
if (!toCancel)
while (true) {
      if (doExecute()) {
        break;
      }
    }
```
**2. 共享变量存储在寄存器或高速缓存、写缓冲器等中，而不是存在主内存里。**
这种情况可以通过“缓存同步”来使共享变量在线程间可见。

**缓存同步**：一个处理器从其自身处理器缓存以外的其他存储部件中读取数据并将其反映（更新）到该处理器的高速缓存的过程。缓存同步通过“冲刷处理器缓存”和“刷新处理器缓存”实现

**冲刷处理器缓存**：使处理器对共享变量的更新写入主内存或者高速缓存中

**刷新处理器缓存**：处理器在读取共享变量时，先从主内存或其他处理器的高速缓存中读取相应变量，更新到自己的缓存中

（volitail保障可见性的原理就是，提示JIT编译器不进行不正常的优化，并在读取volitail变量时刷新处理器缓存，写volitail变量时冲刷处理器缓存）

#### 3.3. 有序性
**程序执行的顺序按照代码的先后顺序执行。**

有序性问题的产生因为代码发生了“重排序”。重排序分为：指令重排序、存储子系统重排序

- 指令重排序
即源代码顺序与处理器最终执行顺序不一致
- 存储子系统重排序
指令执行顺序与源代码一致，但处理器为保障效率，将操作结果从写缓冲器写入高速缓存时没按照指令顺序
（存储子系统即为写缓冲器、高速缓存这类存储子系统）

### 4. 上下文切换
一个线程被暂停，即被剥夺处理器的使用权；另一个线程被选中开始或者继续执行的过程叫做上下文切换

### 5. 线程状态
如下图，可分为6种状态：

![threads2](/assets/threads2.gif)

# 线程同步
线程同步机制是一套用于协调线程间的数据访问和活动的机制

### 1. 锁
Java平台中的锁包括内部锁（`synchronized`）和显示锁(`java.util.concurrent.locks.Lock`和`java.util.concurrent.locks.ReadWriteLock`)

锁通过互斥性保障原子性；获取锁时会刷新处理器缓存，释放锁时冲刷处理器缓存，保障了可见性；虽然锁内部的临界区代码可以被重排序，但在读线程看来，执行顺序与源代码是一致的，所以保障了有序性

- **内部锁（`synchronized`）**
通过`synchronized`关键字实现，线程对锁的申请和释放都由Java虚拟机负责，对锁的调度仅支持非公平调度，不会发生锁泄漏（异常导致未释放锁）
当`synchronized`被修饰在`static`方法上时，对该类所有对象都有效。即所有对象的该方法都是原子性操作。

- **显示锁(`java.util.concurrent.locks.Lock`)**
更灵活自由的锁，通过`Lock`的实现类（如`ReentrantLock`）对锁进行一些操作，即支持公平调度也支持非公平调度，使用不当容易出现锁泄漏。


- **显示锁-读写锁(`java.util.concurrent.locks.ReadWriteLock`)**
改进型的排他锁，分为读锁和写锁，读锁允许多个线程同时读取共享变量，写锁一次只允许一个线程对共享变量进行更新。

**内部锁和显示锁的性能差异：**
显示锁更适合高并发场景，JDK1.6前，高并发场景下，`synchronized`的性能会极速下降，JDK1.6后，对内部锁做了性能改进，内部锁和显示锁差异已经比较小了

### 2. 线程同步的底层原理——内存屏障
Java虚拟机底层借助内存屏障来实现了线程同步的部分功能。

内存屏障是被插入到两个指令之间，禁止编译器、处理器重排序从而保障了有序性，同时会带有刷新处理器缓存和冲刷处理器缓存的功能。

- **按照可见性保障来划分**
内存屏障分为：加载屏障（Load Barrier）和存储屏障（Store Barrier）。
加载屏障作用是刷新处理器缓存；存储屏障作用是冲刷处理器缓存

- **按照有序性保障来划分**
内存屏障分为：获取屏障（Acquire Barrier）和释放屏障（Release Barrier）。
获取屏障在读操作后插入，禁止该读操作与其后的任务读写操作发生重排序；释放屏障在一个写操作之前插入，禁止该写操作与其前面的任何读写操作发生重排序。这两个屏障一起保证了临界区中的任何读写操作不可能被重排序到临界区之外。

内存屏障在锁中的使用：
![](/assets/QQ截图20180304122337_vzbfo9fsw.png)

### 3. volatile
常被称为轻量级锁，作用包括：在不引起上下文切换的情况下，保障可见性、有序性和`long/double`变量读写操作的原子性


#### 3.1. 原理
volatile的原理可以通过内存屏障来很清楚的了解

- **写操作**：
![](/assets/QQ截图20180304135314.png)
释放屏障保证了volatile写操作与该操作之前的任何读、写操作都不会进行重排序，从而保证了volatile写操作之前，任何的读写操作都会先于volatile被提交。保障了有序性
而存储屏障会冲刷处理器缓存，使volatile变量的更新对其他线程可见，该内存屏障与读操作的加载屏障一起保障了可见性

- **读操作**：
![](/assets/QQ截图20180304140055.png)
加载屏障会刷新处理器缓存，使volatile变量读取的为最新值。
获取屏障禁止了volatile读操作之后的任何读写操作与volatile读操作进行重排序。保障了volatile变量读操作之后的任何读写操作，volatile的写线程的更新已经对其可见

#### 3.2. volatile的应用场景
1. 使用volatile变量作为状态标志
2. 使用volatile保障变量的可见性
3. 使用volatile变量替代锁。将一组可变状态变量封装成volatile修饰的实体对象，每次更改时，重新给这个实体对象赋值。
4. 使用volatile实现简易版读写锁
```
/**
 * 基于volatile实现的简易读写锁
 */
public class Counter{
	private volatile long count;

	public long getCount() {
		return count;
	}

	public void increment() {
		synchronized (this) {
			count++;
		}
	}
}
```

### 4. CAS
CAS（Compare and Swap）是对一种处理器指令的称呼。java中通过JNI调用硬件的这种指令，保障了对**单个共享变量**的`read-modift-write`和`check-then-act`操作的原子性。


#### 4.1. CAS原理
CAS是一个原子性的if-then-act操作，当一个客户执行CAS操作时，如果变量V的当前值和客户请求CAS时所调用的变量值A（即变量旧值）相等，则更新该值为B
```
public boolean compareAndSwap(Variable V, Object A, Object B) {
	if(A == V.get()) { //compare,检查变量值是否被其他线程修改过
		V.set(B); //如果没有，更新该值
		return true;
	}
	return false;
}
```
例如`i++`这个操作，本身线程不安全，在不加锁时用volatile保障可见性和有序性，用CAS保障原子性，即可实现线程安全：

```
private volatile long count;

public void increment() {
  long oldValue;
  long newValue;
  do {
    oldValue = count;// 读取共享变量当前值
    newValue = oldValue + 1;// 计算共享变量的新值
  } while (!compareAndSwap(oldValue, newValue));// 调用CAS来更新共享变量的值
}
```

#### 4.2. CAS运用
Java中的`java.util.concurrent.atomic`包中的原子操作类对象，可看作基于CAS实现的增强型volatile变量

### 5. 安全发布与对象逸出
- 发布对象：
使一个对象能够被当前范围之外的代码所使用
- 对象逸出：
一种错误的发布。当一个对象还没有构造完成时，就使它被其他线程所见。或对象的发布结果不是我们期望的

#### 对象逸出的原因
我们期待的对象初始化步骤：
```
// 1、memory = allocate() 分配对象的内存空间
// 2、ctorInstance() 初始化对象
// 3、instance = memory 设置instance指向刚分配的内存
```
实际可能的初始化步骤：对象还没被初始化完成时，对象指针就已经被发布出去
```
// 1、memory = allocate() 分配对象的内存空间
// 3、instance = memory 设置instance指向刚分配的内存
// 2、ctorInstance() 初始化对象
```

这也是双重检查单例模式，为什么单例需要用`volatile`关键字修饰的原因。如果不用`volatile`来修饰单例禁止重排序，在`A`行代码处可能返回的不是一个初始化成功的对象。
```
@ThreadSafe
public class SingletonExample5 {

    // 私有构造函数
    private SingletonExample5() {

    }

    // 单例对象 volatile + 双重检测机制 -> 禁止指令重排
    private volatile static SingletonExample5 instance = null;

    // 静态的工厂方法
    public static SingletonExample5 getInstance() {
        if (instance == null) { // 双重检测机制        // B
            synchronized (SingletonExample5.class) { // 同步锁
                if (instance == null) {
                    instance = new SingletonExample5(); // A - 3
                }
            }
        }
        return instance;
    }
}
```
#### 对象逸出的几种形式：
1. 在构造器中将`this`赋值给一个共享变量
2. 在构造器中将`this`作为方法参数传递给其他方法
3. 在构造器中启动基于匿名类的线程（此时对象还没有构造完成，匿名类线程可能看到的不是初始化成功的对象）

#### 安全发布一个对象的几种方式：
1. 使用`static`关键字修饰对象的引用：
Java中类的初始化采取了延迟加载的技术，即一个类被Java虚拟机加载之后，该类的所有静态变量的值仍然是默认值。直到该类被访问任一静态变量时才初始化。
static关键字能够保证一个线程即使在未使用其他同步机制的情况下，也总是可以读取到一个类的静态变量的初始值（而不是默认值）。
2. 使用`final`关键字修饰对象的引用：
由于重排序，Java中，当一个对象被发布到其他线程时，并不能保证这个对象的所有字段都是初始化完成的。而final字段可以保障被修饰的字段在其被发布前是初始化完毕的。
3. 使用`volatile`关键字修饰对象的引用
4. 使用`AtomicReference`来引用对象
5. 对访问该对象的代码加锁
